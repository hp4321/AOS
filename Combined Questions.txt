1. To create ‘n’ children. When the children will terminate, display total cumulative time children
spent in user and kernel mode

#include<stdio.h>
#include<sys/times.h>
#include<stdlib.h>
#include<unistd.h>
static void pr_times(clock_t real,struct tms *tmsstart,struct tms *tmsend)
{
  static long clktck = 0;
  if(clktck == 0)
  if((clktck = sysconf(_SC_CLK_TCK))<0)
      printf("sysconf error");
  printf("%ld\n",clktck);
  printf("real=%7.2f\n",(real/(double)clktck));
  printf("CU END=%7.2f\n",tmsend->tms_cutime);
  printf("CU START=%7.2f\n",tmsstart->tms_cutime);
  printf("Cs END=%7.2f\n",tmsend->tms_cstime);
  printf("Cs START=%7.2f\n",tmsstart->tms_cstime);
  printf("Child spent %7.2f time in user mode\n",(tmsend->tms_cutime-tmsstart->tms_cutime)/(double)clktck);
  printf("Child spent %7.2f time in kernel mode\n",(tmsend->tms_cstime-tmsstart->tms_cstime)/(double)clktck);
}
 int main()
{
  int n,i;
  printf("How many children processes:-");
  scanf("%d",&n);
  for(i=0;i<n;i++)
  {
       struct tms tmsstart,tmsend;
       clock_t start,end;
       if(fork()==0)
       {
         if((start == times(&tmsstart))==-1)
            printf("time error");
         if((end == times(&tmsend))==-1)
            printf("time error");

	 static long clktck=0;
	 if(clktck == 0)
  	 if((clktck = sysconf(_SC_CLK_TCK))<0)
      	 	printf("sysconf error");
      	 printf("[child %d]pid %d from [parent]pid %d\n",i,getpid(),getppid());
      	 printf("User CPU time,END=%7.2f\n",&tmsend.tms_cutime);
      	 printf("User CPU time,START=%7.2f\n",&tmsstart.tms_cutime);
      	 printf("System(Kernel)CPU time,END=%7.2f\n",&tmsend.tms_cstime);
     	 printf("System(Kernel)CPU time,START=%7.2f\n",&tmsstart.tms_cstime);
     	 printf("Child spent %7.2f time in user mode\n",(tmsend.tms_cutime-tmsstart.tms_cutime)/(double)clktck);
      	 printf("Child spent %7.2f time in kernel mode\n",(tmsend.tms_cstime-tmsstart.tms_cstime)/(double)clktck);
    
      	 exit(0);
      }
 }
 for(i=0;i<n;i++)
 {
   wait(NULL);
 }
}

-----------------------------------------------------------------------------------------------------------------------------------------
2. To generate parent process to write unnamed pipe and will read from it.

#include <stdio.h>
#include <unistd.h>
#define MSGSIZE 16
char* msg1 = "hello, world #1";
char* msg2 = "hello, world #2";
char* msg3 = "hello, world #3";
int main()
{
char inbuf[MSGSIZE];
int p[2], i;
if (pipe(p) < 0)
exit(1);
/* continued */
/* write pipe */
write(p[1], msg1, MSGSIZE);
write(p[1], msg2, MSGSIZE);
write(p[1], msg3, MSGSIZE);
for (i = 0; i < 3; i++) {
/* read pipe */
read(p[0], inbuf, MSGSIZE);
printf("% s\n", inbuf);
}
return 0;
}
/*
Output:
hello, world #1
hello, world #2
hello, world #3 */

-------------------------------------------------------------------------------------------------------------
3. To create a file with hole in it.

#include<fcntl.h>
#include<stdio.h>
#include<unistd.h>

int main(){
    
    int fd,flag;
    char *str1 = "This File Demonstrates Holes";
    fd = creat("MyTextFile.txt",O_RDWR); // will return fd of the file specified
    
    
    //Changing file permission
    system("chmod 777 MyTextFile.txt");
    
    //write to file
    flag = write(fd,str1,28);
    if(flag < 0){
        printf("Error occured !");
        return 0;
    }
    else
    {
        printf("Successfully written\n");
    }
    
    //cursor moving to 30 spaces forward
    lseek(fd,70,SEEK_SET);
    flag = write(fd,str1,28);
    if(flag < 0){
        printf("Error occured !");
        return 0;
    }
    else
    {
        printf("Successfully written\n");
    }
    
    
    system("od -c MyTextFile.txt");
    return 0;
}

-----------------------------------------------------------------------------------------------------------------

4. Takes multiple files as Command Line Arguments and print their inode number

-----------------------------------------------------------------------------------------------------------------------

5. To handle the two-way communication between parent and child using pipe

#include<stdio.h>
#include<unistd.h> //Contains Pipe,write and read, and fork() sys calls 
void main(){
    
    char buff[500];
    int fd1[2],fd2[2],flag,pid;
    
    //Setting up the pipes
    flag = pipe(fd1); // will return 0 on success and -1 on failure
    if(flag < 0){printf("Error While creating a Pipe"); return;}
    else{printf("Pipe1 Successfully Created !\n");}
    flag = pipe(fd2); // will return 0 on success and -1 on failure
    if(flag < 0){printf("Error While creating a Pipe"); return;}
    else{printf("Pipe2 Successfully Created !\n");}
    
    pid = fork();
    if(pid < 0){
        printf("Child Process cannot be created !");
        return;
    }
    else if (pid == 0){
        printf("-------Child Process--------");
        close(fd1[0]);
        close(fd2[1]);
        flag = write(fd1[1],"This message is from the child !", 70);
        if(flag < 0){printf("Error writing to pipe !");return;}
        else{printf("Write Successful !\n");}
        flag = read(fd2[0],buff,70);
        if(flag < 0){printf("Error writing to pipe !");return;}
        else{printf("Write Successful !\n");}
        printf("Printing Parent message from child: %s \n",buff);
    }
    else{
         printf("-------Parent Process--------");
        close(fd1[1]);
        close(fd2[0]);
        flag = write(fd2[1],"This message is from the Parent !", 70);
        if(flag < 0){printf("Error writing to pipe !");return;}
        else{printf("Write Successful !\n");}
        flag = read(fd1[0],buff,70);
        if(flag < 0){printf("Error writing to pipe !");return;}
        else{printf("Write Successful !\n");}
        printf("Printing child message from parent: %s \n ",buff);
        
    }
    
 
    
    return;
    
}

--------------------------------------------------------------------------------------------------

6. Print the type of file where file name accepted through Command Line.

#include <stdio.h>
int main ( int argc, char *argv[] )
{
if ( argc != 2 ) /* argc should be 2 for correct execution */
{
/* We print argv[0] assuming it is the program name */
printf( "usage: %s filename", argv[0] );
}
else
{
// We assume argv[1] is a filename to open
FILE *file = fopen( argv[1], "r" );
/* fopen returns 0, the NULL pointer, on failure */
if ( file == 0 )
{
printf( "Could not open file\n" );
}
else
{
int x;
/* read one character at a time from file, stopping at EOF, which
indicates the end of the file. Note that the idiom of "assign
to a variable, check the value" used below works because
the assignment statement evaluates to the value assigned. */
while ( ( x = fgetc( file ) ) != EOF )
{
printf( "%c", x );
}
fclose( file );
}
}
}

----------------------------------------------------------------------------------------------

7. To demonstrate the use of atexit() function

#include<stdio.h>
#include<stdlib.h>

void functionA()
{
	printf("this is function A\n");
}
void functionB()
{
	printf("this is function B\n");
}
int main()
{
	if((atexit(functionA)!=0)||(atexit(functionB)!=0))
		printf("cant register atexit");
	atexit(functionA);
	atexit(functionB);
	printf("starting main program...\n");
	printf("exiting main program...\n");
	return(0);
}

---------------------------------------------------------------------------------------

8. Open a file goes to sleep for 15 seconds before terminating

#include<fcntl.h>
#include<stdio.h>
#include<unistd.h>

int main(){

  int fd,flag;

  if((fd = open("MyTextFile.txt",O_RDWR)) < 0){
    printf("Error while opening !");
    return 0;
  }
  printf("Sleeping for 15 secs..\n");
  sleep(15);
  printf("Waking up!\n");
  printf("closing file..\n");
  close(fd);
  return 0;
}
----------------------------------------------------------------------------------------

9. To print the size of the file

#include<sys/stat.h>
#include<stdio.h>

int main(int argc, char* argv[]){
  struct stat stat_buf;
  int flag = 0;

  if(argc > 2 || argc < 0){
    printf("Maximum of one argument required !");
    return 0;
  }

  if((stat(argv[1],&stat_buf)) != 0){
    printf("Error !");
    return 0;
  }
  printf("File %s is of %d bytes ",argv[1],stat_buf.st_size);
  return 0;
}

--------------------------------------------------------------------------------------

10. Read the current directory and display the name of the files, no of files in current directory.

#include<stdio.h>
#include<dirent.h>

int main(){

  struct dirent *dirp;
  DIR *dir;
  int i=0;
  dir = opendir(".");
  if(dir){
    while((dirp = readdir(dir))!=NULL){
      printf("%s\n",dirp->d_name);
      i ++ ;
    }
    printf("Number of files : %d",i);
  }
  else{
    printf("Error\n");
  }
  
  return 0;
}

-----------------------------------------------------------------------------------------------

11. Write a C program to implement the following unix/linux command (use fork, pipe and exec system
call)
ls –l | wc –l

#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include<errno.h>
#include<sys/wait.h>
#include <unistd.h>
int main(){
// array of 2 size a[0] is for
// reading and a[1] is for
// writing over a pipe
int a[2];
// using pipe for inter
// process communication
pipe(a);
if(!fork())
{
// closing normal stdout
close(1);
// making stdout same as a[1]
dup(a[1]);
// closing reading part of pipe
// we don't need of it at this time
close(a[0]);
// executing ls
execlp("ls","ls",NULL);
}
else
{
// closing normal stdin
close(0);
// making stdin same as a[0]
dup(a[0]);
// closing writing part in parent,
// we don't need of it at this time
close(a[1]);
// executing wc
execlp("wc","wc",NULL);
}
}
--------------------------------------------------------------------------------------------------------------

12. Write a C program to display all the files from current directory which are created in particular
month

#include<stdio.h>
#include<dirent.h>
#include<sys/stat.h>
#include<time.h>


int main(){

  int flag = 0;
  struct tm *dirtime;
  struct stat stats;
  DIR *dir;
  struct dirent *dirp;
  int month;

  printf("Enter month  1-12 :\t");
  scanf("%d",&month);
  month--;

  dir = opendir(".");
  if(dir){
    while((dirp = readdir(dir))!=NULL ){
      if(stat(dirp->d_name,&stats)==0){
        dirtime = gmtime(&stats.st_ctime);
        if(dirtime->tm_mon == month){

          printf("File : %s \t Time : %d-%d-%d\n",dirp->d_name, dirtime->tm_mday,dirtime->tm_mon+1,dirtime->tm_year+1900);
          
        }
        
      }
    }
    if(dirp==NULL){
      printf("No more files to display in this month !");
    }
  }
  else{
    printf("Error!");
  }

  return 0;  
}
-----------------------------------------------------------------------------------------------------------------

13. Write a C program to display all the files from current directory whose size is greater that n Bytes
Where n is accept from user.

#include"stdio.h"
#include"stdlib.h"
#include"unistd.h"
#include"fcntl.h"
#include"sys/stat.h"
#include"sys/types.h"
#include"dirent.h"
int main(int argc,char*argv[])
{
int n;
DIR *d;
struct dirent *de;
struct stat s;
printf("\n Enter value of n(size)=>");
scanf("%d",&n);
d=opendir(".");
if(d==NULL)
{
printf("unable to open dir");
exit(0);
}
while((de=readdir(d))!=NULL)
{
stat(de->d_name,&s);
if(s.st_size>n)
{
printf("%s\t%d\n",de->d_name,s.st_size);
}
}
return 0;
}
//OUTPUT
/*
[fy@localhost Rohit]$ gedit acc13.c
[fy@localhost Rohit]$ gcc acc13.c;
[fy@localhost Rohit]$ ./a.out
Enter value of n(size)=>10000
[fy@localhost Rohit]$ ./a.out
Enter value of n(size)=>100
. 269
.. 4096
practical1.c 837
bhole 126
practical2.c 660
practical3.c 1055
prac4.c 2028
ass13.c 333
acc13.c 471
a.out 8680
*/
------------------------------------------------------------------------------------------------------------------

14. Write a C program to implement the following unix/linux command
i. ls –l > output.txt

#include<stdio.h>
#include<sys/stat.h>
#include<fcntl.h>
#include<stdlib.h>
#include<time.h>

void sfile(char const filename[]);

char *formatdate(char *str,time_t val)
{
	strftime(str,36,"%d,%m,%Y,%H,%M,%S",localtime(&val));
	return str;
}

int main()
{
	ssize_t read;
	char *buffer=0;
	size_t buf_size=0;
	printf("Enter name of file to check : ");
	read=getline(&buffer,&buf_size,stdin);
	if(read<=0)
	{
		printf("Getline Failed");
		exit(1);
	}
	if(buffer[read-1]=='\n')
		buffer[read-1]=0;

	int s=open(buffer,O_RDONLY);
	if(s==-1)
	{
		printf("File does not exist!");
		exit(1);
	}
	else
	{
		sfile(buffer);
	}
	free(buffer);
	return(0);
}

void sfile(char const filename[])
{
	struct stat sfile;
	char date[36];
	if(stat(filename,&sfile)==-1)
		printf("Error..Exiting");
	printf("\n");
	printf("Access Time :  %s\n",formatdate(date,sfile.st_atime));
	printf("Modify Time :  %s\n",formatdate(date,sfile.st_mtime));
	printf("Change Time :  %s\n",formatdate(date,sfile.st_ctime));

	printf("\n");
	//Accessing data members of stat stuct
	printf("File st_ino     : %d\n",sfile.st_ino);
	printf("File st_mode    : %o\n",sfile.st_mode);
	printf("File st_atime   : %s\n",formatdate(date,sfile.st_atime));
	printf("File st_uid     : %d\n",sfile.st_uid);
	printf("File st_blksize : %d\n",sfile.st_blksize);
	printf("File st_gid     : %d\n",sfile.st_gid);
	printf("File st_blocks  : %d\n",sfile.st_blocks);
	printf("File st_size    : %d\n",sfile.st_size);
	printf("File st_nlink   : %u\n",(unsigned)sfile.st_nlink);

	printf("\nFile Permission : User\n");
	printf((sfile.st_mode & S_IRUSR)?"r":"-");
	printf((sfile.st_mode & S_IWUSR)?"w":"-");
	printf((sfile.st_mode & S_IXUSR)?"x":"-");

	printf("\nFile Permission : Group\n");
        printf((sfile.st_mode & S_IRGRP)?"r":"-");
        printf((sfile.st_mode & S_IWGRP)?"w":"-");
        printf((sfile.st_mode & S_IXGRP)?"x":"-");
	
	printf("\nFile Permission : Other\n");
        printf((sfile.st_mode & S_IROTH)?"r":"-");
        printf((sfile.st_mode & S_IWOTH)?"w":"-");
        printf((sfile.st_mode & S_IXOTH)?"x":"-");
	printf("\n");
}

-------------------------------------------------------------------------------------------------------------

15. Write a C program which display the information of a given file similar to given by the unix / linux
command ls –l <file name> 

#include<stdio.h>
#include<sys/wait.h>
#include<sys/types.h>
#include<unistd.h>
#include<stdlib.h>

int main()
{
	int pid;
	pid=fork();
	if(pid<0)
	{
		//fail
		printf("fork failed");
		exit(-1);
	}
	else if(pid==0)
	{
		//child is executing
		execlp("/bin/ls","ls","-l",NULL);
	}
	else
	{
		//parent is executing
		wait(NULL);
		printf("Child Complete");
		exit(0);
	}
}
-------------------------------------------------------------------------------------------------------

16. Write a C program that behaves like a shell (command interpreter). It has its own prompt say
“NewShell$”. Any normal shell command is executed from your shell by starting a child process to
execute the system program corresponding to the command. It should additionally interpret the
following command.
i) count c <filename> - print number of characters in file
ii) count w <filename> - print number of words in file
iii) count l <filename> - print number of lines in file

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

void make_toks(char *s, char *tok[])
{
	int i=0;
	char *p;
	p = strtok(s," ");
	while(p!=NULL)
	{
 		tok[i++]=p;
		p=strtok(NULL," ");
	}
	tok[i]=NULL;
}

void count(char *fn, char op)
{
	int fh,cc=0,wc=0,lc=0;
	char c;
	fh = open(fn,O_RDONLY);
	if(fh==-1)
	{
 		printf("File %s not found.\n",fn);
		return;
	}
	while(read(fh,&c,1)>0)
	{
		if(c==' ') 
			wc++;
		else if(c=='\n')
 		{
			 wc++;
			 lc++;
 		}
 		cc++;
	}
	close(fh);
	switch(op)
	{
		case 'c': printf("No.of characters:%d\n",cc-1);
			  break;

		case 'w': printf("No.of words:%d\n",wc);
			  break;

		case 'l': printf("No.of lines:%d\n",lc+1);
			  break;

	}
}

int main()
{
	char buff[80],*args[10];
	int pid;
	while(1)
	{
 		printf("myshell$ ");
 		fflush(stdin);
 		fgets(buff,80,stdin);
 		buff[strlen(buff)-1]='\0';
 		make_toks(buff,args);
		if(strcmp(args[0],"count")==0)
 			count(args[2],args[1][0]);
		else if(strcmp(args[0],"exit")==0)
			exit(0);
		else
 		{
 			pid = fork();
 			if(pid>0)
 				wait();
 			else
 			{
 				if(execvp(args[0],args)==-1)
 					printf("Bad command.\n");
 			}
 		}
	}
	return 0;
}
----------------------------------------------------------------------------------------------------------------

17. Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”.
Any normal shell command is executed from your shell by starting a child process to execute the system
program corresponding to the command. It should additionally interpret the following command.
i) list f <dirname> - print name of all files in directory
ii) list n <dirname> - print number of all entries
iii) list i<dirname> - print name and inode of all files

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<dirent.h>
char *buff,*t1,*t2,*t3,ch;
int pid;
void list(char t2,char *t3)
{
DIR *dir;
struct dirent *entry;
int cnt=0;
dir=opendir(t3);
if (dir==NULL)
{
printf("Directory %s not found",t3);
return;
}
switch(t2)
{
case 'f' : while((entry=readdir(dir))!=NULL)
{
printf("%s\n",entry->d_name);
}
break;
case 'n' : while((entry=readdir(dir))!=NULL)
cnt++;
printf("Total No of Entries: %d\n",cnt);
break;
case 'i' : while((entry=readdir(dir))!=NULL)
{
printf("\n%s\t %d",entry->d_name,entry->d_ino);
}
break;
default : printf("Invalid argument");
}
closedir(dir);
}
main()
{
while(1)
{
printf("myshell$");
fflush(stdin);else if(strcmp(t1,"list")==0)
list(t2[0],t3);
else
{
pid=fork();
if(pid<0)
printf("Child process is not created\n");
else if(pid==0)
{
execlp("/bin",NULL);
if(strcmp(t1,"exit")==0)
exit(0);
system(buff);
}
else
{
wait(NULL);
exit(0);
}
}
}
}
/*
[root@localhost ass1]# ./a.out
myshell$list f ass2
rr.C
NPSJP.C
PSJF.C
PRIORITY.BAK
..
.
PP.BAK
PRIORITY.C
PP.Cmyshell$list n ass2
Total No of Entries: 9myshell$list i ass2
rr.C
1452033
NPSJP.C
1452013
PSJF.C 1452032
PRIORITY.BAK
1452016
..
1451875
.
1452001
PP.BAK
1452014
PRIORITY.C 1452017
PP.C 1452015
myshell$ls
#a.c# a.out ass2 a.txt b.c
myshell$pause
*/
---------------------------------------------------------------------------------------------------------------------

18. Write a C program that behaves like a shell (command interpreter). It has its own prompt say “NewShell$”.
Any normal shell command is executed from your shell by starting a child process to execute the system
program corresponding to the command. It should additionally interpret the following command.
i) typeline +10 <filename> - print first 10 lines of file
ii) typeline -20 <filename> - print last 20 lines of file
iii) typeline a <filename> - print all lines of file

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
char *buff,*t1,*t2,*t3,ch;
FILE *fp;
int pid;
void typeline(char *t2,char *t3)                                {
int i,n,count=0,num;
if((fp=fopen(t3,"r"))==NULL)
printf("File not found\n");
if(strcmp(t2,"a")==0)
{
while((ch=fgetc(fp))!=EOF)
printf("%c",ch);
fclose(fp);
return;
}
n=atoi(t2);
if(n>0)
{
i=0;
while((ch=fgetc(fp))!=EOF)
{
if(ch=='\n')
i++;
if(i==n)
break;
printf("%c",ch);
}
printf("\n");
}
else
{
count=0;
while((ch=fgetc(fp))!=EOF)
if(ch=='\n')
count++;
fseek(fp,0,SEEK_SET);
i=0;
while((ch=fgetc(fp))!=EOF)
{
if(ch=='\n')
i++;
if(i==count+n-1)
break;
}
while((ch=fgetc(fp))!=EOF)
printf("%c",ch);
}
fclose(fp);
}
main(){
while(1)
{
printf("myshell$");
fflush(stdin);
t1=(char *)malloc(80);
t2=(char *)malloc(80);
t3=(char *)malloc(80);
buff=(char *)malloc(80);
fgets(buff,80,stdin);
sscanf(buff,"%s %s %s",t1,t2,t3);
if(strcmp(t1,"pause")==0)
exit(0);
else if(strcmp(t1,"typeline")==0)
typeline(t2,t3);
else
{
pid=fork();
if(pid<0)
printf("Child process is not created\n");
else if(pid==0)
{
execlp("/bin",NULL);
if(strcmp(t1,"exit")==0)
exit(0);
system(buff);
}
else
{
wait(NULL);
exit(0);
}
}
}
}
/*
[root@localhost ass1]# cc typeline.c
[root@localhost ass1]# ./a.out
myshell$typeline a s.txt
hello aa welcome
dyp bb
tybcs aa dyp
good morning
dyp gm
myshell$typeline -2 s.txt
good morning
dyp gm            myshell$typeline +3 s.txt
hello aa welcome
dyp bb
tybcs aa dyp
myshell$ls
#a.c# a.out ass2 a.txt b.c
count.c list.c search.c s.txt typeline.c
myshell$pause
*/
--------------------------------------------------------------------------------------------------------------

19. Write a C program that behaves like a shell (command interpreter). It has its own prompt say
“NewShell$”.Any normal shell command is executed from your shell by starting a child process to
execute the system program corresponding to the command. It should
i) additionally interpret the following command.
ii) search f <pattern> <filename> - search first occurrence of pattern in filename
iii) search c <pattern> <filename> - count no. of occurrences of pattern in filename
iv) search a <pattern> <filename> - search all occurrences of pattern in filename

#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<string.h>
char *buff,*t1,*t2,*t3,*t4,ch;
FILE *fp;
int pid;
void search(char *t2,char *t3,char *t4)
{
int i=1,count=0;
char *p;
if((fp=fopen(t4,"r"))==NULL)
printf("File not found\n");
else
{
if(strcmp(t2,"f")==0)
{
while(fgets(buff,80,fp))
{
if((strstr(buff,t3))!=NULL)
{
printf("%d: %s\n",i,buff);
break;
}
}
i++;
}
else if(strcmp(t2,"c")==0)
{
while(fgets(buff,80,fp))
{
if((strstr(buff,t3))!=NULL)
{
count++;
}
}
printf("No of occurences of %s= %d\n",t3,count);
}
else if(strcmp(t2,"a")==0)
{
while(fgets(buff,80,fp))
{
if((strstr(buff,t3))!=NULL)
{
printf("%d: %s\n",i,buff);
}
i++;
}
}
else
printf("Command not found\n");
fclose(fp);
}
}
main()
{
while(1)
{
printf("myshell$");
fflush(stdin);
t1=(char *)malloc(80);
t2=(char *)malloc(80);
t3=(char *)malloc(80);
t4=(char *)malloc(80);
buff=(char *)malloc(80);
fgets(buff,80,stdin);
sscanf(buff,"%s %s %s %s",t1,t2,t3,t4);
if(strcmp(t1,"pause")==0)
exit(0);
else if(strcmp(t1,"search")==0)
search(t2,t3,t4);
else
{
pid=fork();
if(pid<0)
printf("Child process is not created\n");
else if(pid==0)
{
execlp("/bin",NULL);
if(strcmp(t1,"exit")==0)
exit(0);
system(buff);
}
else
{
wait(NULL);
exit(0);
}
}
}
}

/*
[root@localhost ass1]# cc search.c
[root@localhost ass1]# ./a.out
myshell$search f aa s.txt
1: hello aa welcome
myshell$search c dyp s.txt
No of occurences of dyp= 3
myshell$search a dyp s.txt
2: dyp bb
3: tybcs aa dyp
5: dyp gm
myshell$ls
#a.c# a.out a.txt b.c count.c list.c search.c s.txt typeline.c
myshell$pause
*/
----------------------------------------------------------------------------------------------------------

20. Write a C program which receives file names as command line arguments and display those
filenames in ascending order according to their sizes.
i) (e.g $ a.out a.txt b.txt c.txt, …)

#include <stdio.h>
#include<sys/types.h>
#include<fcntl.h>
#include<string.h>
int main(int argc, char *argv[])
{ int counter,i,j,temp,res[10];
char *fname[argc],*temp2[argc];
printf("Unsorted files \n");
for(i=1;i<argc;i++)
{ int fd,of;
fd=open(argv[i],O_RDONLY);
of=lseek(fd,0,SEEK_END);
res[i]=of;
printf("%s\t%d\n",argv[i],of);
fname[i] = strdup(argv[i]);
}
for(i=1;i<argc;i++)
{ for(j=i+1;j<argc;j++)
{ if(res[i]>res[j])
{ temp=res[i];
res[i]=res[j];
res[j]=temp;
strcpy(temp2,fname[i]);
strcpy(fname[i],fname[j]);
strcpy(fname[j],temp2);
}
}
}
printf("Files in ascending order according to their sizes\n");
for(i=1;i<argc;i++)
{ printf(" %d %d %s\n",i,res[i],fname[i]);
}
return 0;

}
-------------------------------------------------------------------------------------------------------------

21. Write a C program which create a child process which catch a signal sighup, sigint and sigquit. The Parent
process send a sighup or sigint signal after every 3 seconds, at the end of 30 second parent send sigquit signal
to child and child terminates my displaying message "My DADDY has Killed me!!!”. 

#include<stdio.h> 
#include<signal.h> 
#include<stdlib.h> 
void sighup(); 
void sigint(); 
void sigquit(); 
main() { 
int pid,i,j,k;
 if ((pid = fork() ) < 0) {
 perror("fork");
 exit(1); 
} 
if ( pid == 0) { 
signal(SIGHUP,sighup);
 signal(SIGINT,sigint);
signal(SIGQUIT,sigquit);
 for(;;);
 } else { 
j=0; 
for(i=1;i<=5;i++) {
 j++;
 printf("PARENT: sending SIGHUP Signal : %d\n",j);
 kill(pid,SIGHUP);
 sleep(3);
 printf("PARENT: sending signal : %d\n",j);
 kill (pid,SIGINT);
 sleep(3);
 }
 sleep(3);
 printf("Parent sending SIGQUIT\n");
 kill(pid,SIGQUIT);
 } }
 void sighup() { 
signal(SIGHUP,sighup);
 printf("Child: I have received sighup\n");
 } 
void sigint() { 
signal(SIGINT,sigint); 
printf("Child: I have received sighINT\n");
 } 
void sigquit() { 
printf("My daddy has killed me\n");
 exit(0);
}
--------------------------------------------------------------------------------------------------------------

22. Write a C program to implement the following unix/linux command (use fork, pipe and exec system
call). Your program should block the signal Ctrl-C and Ctrl-\ signal during the execution.
i. ls –l | wc –l

#include "stdio.h" 
#include "stdlib.h" 
#include "fcntl.h" 
#include "unistd.h" 
#include "signal.h" 
void sh(int sig) { 
printf("\n signal cought");
 fflush(stdout); 
} 
int main() {
 int p[2],n;
 signal(SIGINT,sh);
 signal(SIGQUIT,sh);
 pipe(p);
 n=fork();
 if(n==0) { 
sleep(5);
 close(p[0]);
 close(1);
 dup(p[1]);
 close(p[1]);
 execlp("ls","ls","-l",NULL);
 } else { 
wait();
 close(p[1]);
 close(0);
 dup(p[0]);
 close(p[0]);
 execlp("wc","wc","-l",NULL);
 }
-----------------------------------------------------------------------------------------

23. Write a C Program that demonstrates redirection of standard output to a file.

#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <unistd.h>
#include <sys/wait.h>
#include <fcntl.h>
void sighup();
void sigint();
void sigquit();
void main()
{ int pid,file,n;
char command[80],t1[20],t2[20],t3[20],t4[20];
printf("NewShell$");
fflush(stdin);
fgets(command,80,stdin);
if ((pid = fork()) < 0)
{ perror("fork");
exit(1);
}
if (pid == 0)
{ signal(SIGHUP, sighup);
signal(SIGINT, sigint);
signal(SIGQUIT, sigquit);
for (;;) ;
}
else { /* parent */
printf("\nPARENT: sending SIGHUP\n\n");
kill(pid, SIGHUP);
sleep(5);
printf("\nPARENT: sending SIGINT\n\n");
kill(pid, SIGINT);
file = open("a.c", O_CREAT|O_WRONLY, S_IRWXU);
if(file){ dup2(file, 1); system(command); }
sleep(3);
printf("\nPARENT: sending SIGQUIT\n");
kill(pid, SIGQUIT);
sleep(5);
}
}
// sighup() function definition
void sighup()
{ signal(SIGHUP, sighup); /* reset signal */
printf("CHILD: I have received a SIGHUP\n");

}
// sigint() function definition
void sigint()
{ signal(SIGINT, sigint); /* reset signal */
printf("CHILD: I have received a SIGINT\n"); }

// sigquit() function definitions
void sigquit()
{ printf("\nParent killed child ..");
exit(0);
}
-----------------------------------------------------------------------------------------------------

24. Write a program that illustrates how to execute two commands concurrently with a pipe.

#include<stdio.h> 
#include <unistd.h> 
#include <sys/types.h> 
#include <stdlib.h> 
int main() {
 int pfds[2]; 
char buf[80]; 
if(pipe(pfds)==-1) {
 perror("pipe failed");
 exit(1);
 } 
if(!fork()) {
 close(1); 
dup(pfds[1]);
 system("ls -l");
 } else {
 printf("parent reading from pipe \n");
 while(read(pfds[0],buf,80)) 
printf("%s \n" ,buf);
 } 
}
----------------------------------------------------------------------------------------

25. Write a C program that illustrates suspending and resuming processes using signals.

#include <stdio.h>
#include <ospace/unix.h>
int child_function()
{
while (true) // Loop forever.
{
Printf("Child loop\n");
os_this_process::sleep( 1 );
}
return 0; // Will never execute.
}
int main()
{
os_unix_toolkit initialize;
os_process child ( child function ); // Spawn child.
os_this_process::sleep( 4 );
printf("child.suspend()\n");
child.suspend();
printf("Parent sleeps for 4 seconds\n");
os_this_process::sleep (4);
printf("child.resume()");
child.resume ();
os_this_process::sleep (4);
printf("child.terminate()");
child.terminate ();
printf("Parent finished");
return 0;
}
/*
Output:
Child loop
Child loop
Child loop
Child loop
Child loop
child.suspend()
Parent sleeps for 4 seconds
child.resume()
Child loop
Child loop
Child loop
Child loop
child.terminate()
Child loop
Parent finished */
--------------------------------------------------------------------------------------

26. Write a C program that illustrates inters process communication using shared memory.

#include<stdio.h>
#include<sys/types.h>
#include<sys/ipc.h>
#include<sys/shm.h>
Struct country
{
Char name[30];
Char capital_city [30];
Char currency[30];
Int population;
};
Int main(int argc,char*argv[])
{
Int shm_id;
Char*shm_addr;
Int*countries_num;
Struct country*countries;
Struct shmid_ds shm_desc;
Shm_id=shmget(100,2048,IPC_CREAT|IPC_EXCL\0600);
If(shm_id==-1){
Perror(“main:shmget:”);
Exit(1);
}
Shm_addr=shmat(shm_id,NULL,0);
If(!shm_addr){
Perror(“main:shmat:”);
Exit(1);
}
Countries_num=(int*)shm_addr;
countries_num=0;Countries=(struct country)((void*)shm_addr sizeof(int));
Strcpy(countries[0],name,”U.S.A”);
Strcpy(countries[0],capital_city,”WASHINGTON”);
Strcpy(countries[0],currency,”U.S.DOLLAR”);
Countries[0].population=250000000;
( countries_num) ;
Strcpy(countries[1].name,”israel”);
Strcpy(countries[1].capital_city,”jerushalem”);
Strcpy(countries[1].currency,”NEW ISRAEL SHEKED”);
Countries[1].population=6000000;
(*countries_num) ;
Strcpy(countries[2].name,”France”);
Strcpy(countries[2].capital_city,”paris”);
Strcpy(countries[2].currency,”Frank”);
Countries[2].population=60000000;
(*countries_num) ;
For(i=0;i<(*countries_num);i )
{
Printf(“country%d:\n”,i 1);
Printf(“name:%d:\n”,i 1);
Printf(“currency:%s:\n”,countries[i].currency);
Printf(“population:%d:\n”,countries[i].population);
}
If(shmdt(shm_addr)==-1){
Perror(“main:shmdt:”);
}
If(shmctl(shm_id,IPC_RMID,&SHM_DESC)==-1)
{
Perror(“main:shmctl:”);
}
return 0;
}

/*
Output:
Student@ubuntu:~$gcc shm.c
Student@ubuntu:~$ ./a.outShared memory ID=65537 child pointer 3086680064
Child value =1
Shared memory ID=65537 child pointer 3086680064
Parent value=1
Parent value=42
Child value=42
*/
------------------------------------------------------------------------------------------